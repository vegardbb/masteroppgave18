\section{Aggregatorienterte datamodeller (også kjent som NoSQL)}

% Kanskje jeg bør forklare ytterligere hva aggregat-orientert betyr?
Ifølge \cite{sadalage2013} kan nøkkel-verdi-lagre (eng. key-value store), kolonnefamilelagre (eng. column family store) og dokumentlagre (eng. documents store) ordnes under én og samme ''art'' av NoSQL-databaser: Aggregatorienterte databasesystem (eng. aggregate oriented databases).

Den enkle måten å forklare hva det vil si å ha en aggregatorientert datamodell er ved å beskrive hva det ikke er. I den relasjonelle datamodellen deles forskjellige former for informasjon inn i relasjoner, og tilhørende data inndeles i atomiske, disjunkte enheter kalt \emph{tupler}. En tupel er en flat, endimensjonal liste av verdier som hver korresponderer til nøyaktig ett attributt av relasjonen tupelen er lagret i.

Det foreligger derfor visse begrensinger på denne datastrukturen. Til eksempel kan ikke en enkelt tupel nøstes inn i en annen, og hvert attributt i tupelen har én atomisk korresponderende verdi, aldri en liste av verdier. Her kan man kontre med at nyere versjoner av MariaDB støtter JSON-objekter som datatype. JSON-objekter er potensielt komplekse dataenheter som kan inneholde nøstede datastrukturer. Men et objekt ansees av datalageret som én kohesiv, helhetlig dataenhet i form av streng, så det argumentet faller. Ettersom tupler er den laveste dataenheten i den relasjonelle modellen kan man si at spørringer opererer med og returnerer (et helt antall) tupler \citep{sadalage2013}.

Men så har vi den aggregatorienterte modellen, en måte å tenke på data som tillater den enkelte datamodellør å definere dataenheter i stedet for å tvinge vedkommende til å konformere med en forhåndsbestemt minste enhet, slik tilfellet er i den relasjonelle modellen. Denne fleksibiliteten i struktureringen av data er et sentralt fellestrekk nøkkel-verdi-lagre som Dynamo og Redis deler med kolonnefamilie-lagre som Cassandra og HBase og dokumentdatabaser som MongoDB og CouchDB. Derfor definerer \cite{sadalage2013} en felles kategori for disse tre NoSQL-typene: ''Aggregatorienterte databasesystem''.

Begrepet ''aggregat'' (må ikke forveksles med det matematiske verbet som betegner en operasjon på en gruppe av tupler) er lånt fra domenedrevet design og er definert som en samling sammenknyttede objekter som en datamodellør ønsker å behandle som en datamanipulasjonsenhet. Når komplekse aggregater aksesseres, gjøres det med et oppslag på én enkelt nøkkel, så får man både dataobjektet med den tilhørende nøkkelen samt eventuelle assosierte dataobjekter. Å utføre en tilsvarende lesing av to assosierte relasjoner i for eksempel MariaDB krever først oppslag i en tabell på dens nøkkelverdi, deretter enda et oppslag på en fremmednøkkel i den assosierte tabellen, altså må en JOIN-operasjon utføres. 

Lesing av aggregerte dataobjekter medfører altså at man med ett enkelt oppslag får både i pose og sekk. Aggregatmodellen er også en enklere datamodell å forholde seg til for de som programmerer selve applikasjonen som behandler dataene. De enkelte aggregater, det vil si applikasjonsprogrammererens definisjon for databehandlingsenhet utgjør en naturlig enhet for replikering i en klynge av enkeltstående databasenoder. I et distribuert databasesystem gjelder det å minimalisere antall noder som kontaktes for hver spørring. Når konsepter settes sammen eksplisitt i datamodellen slik som vi ser i de fleksible dokumentstrukturene til Mongo, vet databasen hvilke dataenheter som skal aksesseres samtidig, og som derfor naturlig nok bør plasseres på én og samme node.

\cite{sadalage2013} kaller relasjonelle database og grafdatabaser for \textbf{aggregat-uvitende}. Deres datamodeller betrakter ikke aggregater eller sammensatte datastrukturer i deres dataoperasjoner. Aggregat-uvitenhet er ikke nødvendigvis et dårlig designvalg, ettersom det ikke alltid er opplagt for den enkelte webapplikasjonsutvikler hvilke enhetsbegrensinger i datamodellen som er logiske, iallfall ikke før datamodellen er definert for første gang og revidert to til tre ganger i løpet av utviklingsprosessen. Den lagrede dataen kan ha mange forskjellige brukskontekster, avhengig av applikasjonens funksjonelle krav som ofte blir forandret underveis i applikasjonens livssyklus.

En enkelt aggregatstruktur kan ikke medføre optimale spørringsytelse for alle mulige brukskontekster. Her gjelder det for utvikleren å prioritere den mest typiske leseoperasjonen tjenesten utsettes for. Hvis applikasjonen ikke har en slik primær aksess – struktur på dataobjektene kan man like godt modellere dem på et aggregat-uvitende vis. I en aggregat-uvitende modell har brukskonteksten ingen innvirkning på spørringen, fordi operasjonsenheten er én enkelt tupel i MariaDB (én enkelt data-node i en grafdatabase som Orient) uansett hvordan konseptene er satt sammen.

Transaksjoner er en velprøvd og høyt akseptert logisk modell for databehandling. Relasjonelle databaser tillater oppdatering av eller lesing av tupler i opptil flere relasjoner innen et sett med atomiske operasjoner. Det er den enkelte mengden av hendelser som heter for en transaksjon. En transaksjon avgrenser mengden av hendelser og skriver enten samtlige eller ingen endringer til disk.

Transaksjonenes egenskaper beskrives med akronymet ACID: De er atomiske, dvs at samtlige hendelser i transaksjonen blir enten gjennomført fullstendig eller ei; konsistente (eng. ''Consistent''), dvs at to transaksjoner som kjører parallellt alltid medfører det samme sluttresultatet; isolerte, det vil si holdbare i den grad transaksjonen persisteres til disk (eng. ''Durable''). Transaksjonsmodellen fremmer en spesifikk handling, \texttt{COMMIT}, som signaliserer at endringene spesifisert i den enkelte transaksjon er blitt gjort permanente.

Aggregatorienterte databasesystemer innehar ikke ACID - egenskapene på samme vis som relasjonelle databasesystemer. Imidlertid støtter de naturlig atomiske manipulasjoner på ett eneste aggregat av gangen. Operasjoner på flere aggregater må derfor handteres i kildekoden til applikasjonen, spørring for spørring, der et unntak kastes hvis én av spørringene mislykkes. Å emulere transaksjoner i enkeltaggregater inngår som en viktig faktor i hvordan aggregatene defineres i datamodellen \citep{sadalage2013}.

% Skriv om tre ulike aggregat - orienterte datamodeller
Fowler og Sadalage omtaler tre datamodeller som opererer med aggregater. Nøkkel-verdimodellen behandler aggregat som en ugjennomsiktig helhet \citep{sadalage2013}. Altså går det ikke an å hente deler av aggregatet ved et nøkkeloppslag. Dokumentmodellen eksponerer aggregatet til databasen, og tillater dermed delvise spørringer. I og med at dokumentmodellen også er skjemaløs går det ikke an å optimalisere spørringer på hele eller deler av aggregatet. Kolonnefamilier inndeler aggregatet i grupper, noe som tillater databasen å operere på hver av disse gruppene som en egen dataenhet, lik som attributter i tuplene i den relasjonelle modellen. Selv om kolonnefamilier gir opp full skjemaløshet, har databasen nå mulighet til å nytte eksponeringen av attributter/kolonner til å optimalisere aksesseringer.

Semistrukturerte datamodeller, en iboende egenskap i de aggregatorienterte modellene \cite{sadalage2013} presenterer, gir den som er interessert i rullerende oppgradering av distribuerte webapplikasjoner en svært fleksibel vei hva angår dataskjema-oppgradering. Sett fra databasetjenesten sitt perspektiv er det ikke noe i veien for at strukturen i ''verdiene'' tilknyttet nøklene i datalageret ikke er samstemte seg imellom, i motsetning til den rigide ordningen av tupler i relasjonsdatabaser som MariaDB og PostgresSQL. Det er nemlig ikke alle typer skjemaendringer som lar seg utføres i databasetjenere på rullerende vis. Et gjenstående problem med rullerende applikasjonsoppdatering er, uansett hvor strukturert applikasjonens datamodell er, at mens node etter node skiftes ut til en ny instans vil instanser av den oppgraderte applikasjonstjeneren generelt sett respondere på brukerforespørsler på en annerledes måte enn instanser av den gamle versjonen som ennå ikke er oppgradert. Dette problemet er kjent under navnet ''Mixed Version Race'', som er et gjennomgående tema i \cite{dumitras2010upgrade,dumitracs2009upgrades}.

% TODO: Mer om aggregatorienterte databasesystem
% Nøkkel-verdi-lagre
%  Dynamo - V
%  Riak
%  Redis / KVolve
% Kolonnefamilielagre
%  Cassandra
% Hvordan høy tilgjengelighet oppnåes i NoSQL - databasearkitekturer
%  PACELC
%  BASE
% Dynamo - feiltoleranse gjennom replikering
