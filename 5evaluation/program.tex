\section{WebshopSimulator} \label{prog}

Webapplikasjonen som DBUpgradinator testes på, kalles for \emph{WebshopSimulator}. Dens arkitektur følger både det logiske, det prosessmessige og det fysiske perspektivet skissert i figurer \ref{fig5}, \ref{fig6}, \ref{fig7}, \ref{fig8}, \ref{fig9}, og \ref{fig10}. Testapplikasjonen etterkommer også systembegrensningene opplistet i delkapittel 4.2.2. Dette delkapitlet skisserer strukturen til testapplikasjonens kildekode, dets avhengigheter, og hvordan tjenerprogrammet blir kompilert til en kjørbar .jar - fil.

\subsection{Simulasjon av brukerforespørsler}

Et klientprogram, skrevet i Javscript, genererer og sender forespørsler til det simulerte produksjonsmiljøet DBUpgradinator testes i. Dette skriptet kjøres i kjøretidsmiljøet NodeJS, fra en norsk datamaskin i Trondheim. Klientprogrammet kalles for \emph{WebAppSimulator}\footnote{Kildekoden til simulatoren er tilgjengelig fra URL \url{https://github.com/vegardbb/DBUpgradinator/tree/master/demo/webappsimulator}.}. Dets hovedoppgave er å simulere en kontinuerlig serie med forespørsler som jevnfordeles blant applikasjonsinstansene. Programmets funksjonalitet kan i korte trekk inndeles i tre satser:

\begin{enumerate}
  \item Programmet sender klyngen av tjenere en serie av POST-forespørsler, slik at nye aggregater lagres på hver av de tomme nodene i databasen. Den totale datamengden som sendes over TCP/IP er begrenset til under én gigabyte, slik at testingen ikke tar altfor lang tid. Samtidig holder en egen loggeprosess styr på ID-verdiene som genereres av tjenerne som tilsendes denne simulerte klienten
  \item Etter at den første satsen er ferdig, terminerer programmet. Da må applikasjonsloggene til hver av tjenerinstansene transformeres til én liste av unike IDer. Til å oppnå dette formålet brukes tekstbehandlingsverktøyet Vim, en kommandolinjeapplikasjon som kan redigere alle linjer i loggen samtidig ved hjelp av regulære uttrykk og dets kraftige kommandolinjesyntaks. Dernest må klientsimulasjonsprogrammet redigeres slik at listen av aggregat-IDer blir lest inn fra korrekt filsti, og slik at funksjonen som kjører den tredje satsen blir kjørt neste gang programmet blir startet opp fra kommandolinjen
  \item Programmet sender applikasjonstjenerne én HTTP-forespørsel per ID i listen som ble oppretttet i forrige steg. Hver forespørsel kan enten være en PUT \- forespørsel eller en GET \- forespørsel. Funksjonen \texttt{Math.random()} brukes til å bestemme hvilket av de to verbene forespørselen kaller på en tjener
\end{enumerate}

For å generere data til POST - forespørslene i steg 1 og PUT - forespørslene i steg 3, brukes en komma\-separert seed-fil som inneholder en tabell der hver rad har en strengverdi for fornavn, etternavn, telefonnummer, gateadresse, poststed, delstat, postkode, og land\footnote{Navn - og addresser i seed-filen stammer fra gratistjenesten Fake Name Generator, som tilbyr inntil 100 000 navn og addresser i en kommaseparert fil per bestilling. URL: \url{https://www.fakenamegenerator.com/order.php}}. Simulasjonsprogrammet leser inn seedfilen og grupperer hver av kolonnene i tabellen til et sett med lister, der hver liste er assosiert med ett av de åtte tidligere nevnte kolonnenavnene.

Ved hjelp av pakken ''node-fetch'' genererer skriptet HTTP-forespørsler asynkront, det vil si at det ikke venter på svar fra applikasjonstjenerne for hver tilsendt forespørsel før den neste sendes. En funksjon i skriptet, kalt \texttt{chooseRandom}, returnerer et pseudotilfeldig valgt element fra et liste-parameter. Denne funksjonen brukes til å velge en tilfeldig applikasjonstjener som skal motta en forespørsel, fra en liste av URL-er. Den samme funksjonen kalles på for å generere hvert attributt i et aggregat som enten skal postes eller oppdateres i databasen. Prosedyren for generering av PUT - forespørsler skiller seg ut fra generering av POST-forespørsler og med at PUT-endepunktet til WebShopSimulator sitt API krever et \emph{id}-parameter.

