Oppgaven implementerer en frittstående applikasjonsmodul som forsørger støtte for automatisk dataoverføring ved dataaksessering, benevnt som ''lazy data migration'' av \cite{saur2016}, og samtidig tester det ut i et simulert produksjonsmiljø med en aggregatorientert datamodell.

\section{Inspirasjoner fra KVolve}

Implementasjonen av migrasjonsløsningen er i stor grad fundamentert på de samme tre sentrale karakteristikkene som KVolve har.

\begin{description}
  \item [Versjonering av aggregat] KVolve kopler sammen logiske versjonsidentifikatorer med aggregatnøkler. Forskjellige versjoner av aggregatene knyttes til forskjellige nøkkel\-prefiks\-strenger, det vil si at at to aggregat som er skrevet innen samme skjemaversjon av applikasjonen har samme nøkkelprefiks-streng. Til eksempel er to aggregat \emph{k:y} og \emph{k:x} begge skrevet under skjemaversjon \emph{k}. Derfor identifiseres begge med prefikset \emph{k:}. En applikasjon som sender en spørring til databasen, indikerer hvilken skjemaversjon den vil se \citep{saur2016}.
  % Revider, og skriv om - bruk egne ord
  \item [Oppdaterings-spesifikasjoner og aggregat-transformasjonsfunksjoner] Når en datamodell skal oppgraderes installerer databaseadministratoren en programkompilert spesifikasjon som beskriver det nye versjonsprefikset som identifiserer versjonen til det neste dataskjemaet, samt en mengde aggregat-transformasjonsfunksjoner som brukes til å oppgradere visse aggregater. Enhver transformasjonsfunksjon har et prefiks i sitt navn, \emph{p} som indikerer skjemaversjonen til aggregater funksjonen skal kalles på.
  \item [Aggregat-transformasjon ved dataaksess] Aggregater lagret i KVolve blir ikke automatisk oppgradert når en ny oppdateringsspesifikasjon installeres i databasen. Når en ny versjon av applikasjonstjeneren starter vil den handtere brukerforespørsler og deretter sende GET og SET - operasjoner til databasen. Hvis en GET - operasjon treffer et aggregat som har en eldre skjemaversjon, men ikke den nyeste, vil en transformasjonsfunksjon kalles for å oppgradere aggregatet. Deretter kan det returneres til applikasjonsinstansen med den nyeste skjemaversjonen. Hvert enkelt aggregat blir altså oppgradert ved forespørsel, og ikke på ivrig, tvungen vis som direkte respons på at en oppgradering er kommisjonert. I KVolve blir applikasjonsinstanser hvis skjemaversjon er utdatert, automatisk frakoplet databasen og får ikke lov til å sende forespørsler. Slik hindrer \cite{saur2016} et mikset versjonsmiljø og sikrer konsistente skjemaversjoner.
\end{description}

Oppgavens programvareløsning, DBUpgradinator, er preget av noen annerledes designvalg som passer bedre til en likemannsarkitektur. Det mest vesentlige avviket er at datamodelloppgraderingsløsningen, som implementeres i denne oppgaven, tillater miksing av skjemaversjoner blant applikasjonstjenerne, slik at løsningen blir kompatibel med rullerende oppgraderingsprosedyrer. Om datamodellen må oppgraderes på grunn av endringer i applikasjonslogikken, så skal ikke det gå utover tjenesteytelsen til de uoppgraderte applikasjonstjenerne her og nå. For DBUpgradinator kan vi ha persistert to aggregat, \emph{k:x} og \emph{j:x}, som begge i prinsippet peker på samme ''dataobjekt'', men for to forskjellige skjemaversjoner. Dette scenariet er ikke tillatt i KVolve.

Til grunn for denne designavgjørelsen ligger replikeringsmønsteret til Redis. Redis bruker Mester-Slave - mønsteret. Mester-Slave - replikering innebærer at én node i en databaseklynge velges av de andre nodene til å ha vervet som klyngens mester, og blir mesterens slaver. Mesternoden har ansvaret for å distribuere skriveforespørsler utover klyngen, så vel som replikering av skriveoperasjoner. Fordi mesternoden håndterer samtlige skriveoperasjoner i klyngen, er replikakonsistens lettere å opprettholde enn for en likemannsarkitektur. Derfor er migrasjonsløsningen til Kvolve implementert på databasenivået fra det logiske perspektiv. Likemannsreplikerte systemer som Project Voldemort prioriterer tilgjengelighet for interaksjon med databasen over konsistente replikaer. Derfor er DBUpgradinator implementert i applikasjonsnivået sett fra det logiske perspektiv.

Et annet designmessig avvik ligger i programmeringsspråket brukt til å implementere DBUpgradinator, Java. Proof-of-concept-implementasjonen av KVolve er skrevet i C. I et objektorientert språk som Java, kan klasser brukes til å modellere oppdateringsspesifikasjonen. En klasse kalt \textbf{AbstractAggregateTransformer} inneholder en transformasjonsfunksjon, kalt \emph{transformAggregate}. Denne klassen har to tilstandsvariabler. Den ene indikerer versjonen til skjemaet som data migreres fra. Den andre tilstandsvariablen indikerer versjonen til skjemaet som data migreres til.

KVolve - implementasjonen til \cite{saur2016} kan også brukes til å oppgradere applikasjonstjenere, i artikkelen brukes Redis - modulen \underline{Amico} som et praktisk eksempel. I tillegg er KVolve innstilt på å vise et logisk konsistent bilde på datalget for webapplikasjonen som opererer på den, av hensyn til \cite{dumitras2009nodowntime} sine krav referert til i delkapittel \ref{imagolist}. Når man implementerer en liknende tjeneste i en høytilgjengelig applikasjon, må man være obs på at Amazon Dynamo er designet primært for å fremme tilgjengelighet for skriveoperasjoner.

