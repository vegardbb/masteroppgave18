\section{Inspirasjoner fra KVolve}

Oppgaven implementerer en frittstående applikasjonsmodul som forsørger støtte for automatisk dataoverføring ved dataaksessering, benevnt som ''lazy data migration'' av \cite{saur2016}, og samtidig tester det ut i et realistisk simulert produksjonsmiljø med datamodellen som vist i \ref{fig1} og \ref{fig2}.

Implementasjonen av migrasjonsløsningen er i stor grad fundamentert på de samme tre sentrale karakteristikkene som KVolve har.

\begin{description}
  \item [Versjonering av aggregat] KVolve kopler sammen logiske versjonsidentifikatorer med aggregatnøkler. Forskjellige versjoner av aggregatene knyttes til forskjellige nøkkelprefiks-strenger, det vil si at at to aggregat som er skrevet innen samme skjemaversjon av applikasjonen har samme nøkkelprefiks-streng. Til eksempel er to aggregat \emph{k:y} og \emph{k:x} begge skrevet under skjemaversjon \emph{k}, derfor identifiseres begge med prefikset \emph{k:}. En applikasjon som sender en spørring til databasen indikerer hvilken skjemaversjon den vil se \citep{saur2016}.
  \item [Oppdaterings-spesifikasjoner og aggregat-transformasjonsfunksjoner] Når en datamodell skal oppgraderes installerer databaseadministratoren en programkompilert spesifikasjon som beskriver det nye versjonsprefikset som identifiserer versjonen til det neste dataskjemaet, samt en mengde aggregat-transformasjonsfunksjoner som brukes til å oppgradere visse aggregater. Enhver transformasjonsfunksjon har et prefiks i sitt navn, \emph{p} som indikerer skjemaversjonen til aggregater funksjonen skal kalles på.
  \item [Aggregat-transformasjon ved dataaksess] Aggregater lagret i KVolve blir ikke automatisk oppgradert når en ny oppdateringsspesifikasjon installeres i databasen. Når en ny versjon av applikasjonstjeneren starter vil den handtere brukerforespørsler og deretter sende GET og SET - operasjoner til databasen. Hvis en GET - operasjone treffer et aggregat som har en eldre skjemaversjon men ikke den nyeste, vil en transformasjonsfunksjon kalles for å oppgradere aggregatet slik at det kan returneres til applikasjonsinstansen med den nyeste skjemaversjonen. Hvert enkelt aggregat blir altså oppgradert ved forespørsel, og ikke på ivrig, tvungen vis som direkte respons på at en oppgradering er kommisjonert. I KVolve blir applikasjonsinstanser hvis skjemaversjon er utdatert automatisk frakoplet databasen og får ikke lov til å sende forespørsler. Således hindrer \cite{saur2016} et mikset versjonsmiljø og sikrer konsistente skjemaversjoner.
\end{description}

Oppgavens programvareløsning, DBUpgradinator, er preget av noen annerledes designvalg som passer bedre til en likemannsarkitektur. Det mest vesentlige avviket er at datamodelloppgraderingen tillater miksing av skjemaversjoner blant applikasjonstjenerne. Om datamodellen må oppgraderes på grunn av endringer i applikasjonslogikken så skal ikke det gå utover tjenesteytelsen til de uoppgraderte applikasjonstjenerne her og nå. For DBUpgradinator kan vi ha persistert to aggregat, \emph{k:x} og \emph{j:x}, som begge i prinsippet peker på samme ''dataobjekt'', men for to forskjellige skjemaversjoner. Dette scenariet er ikke tillatt i KVolve.

Et annet designmessig avvik ligger i programmeringsspråket brukt til å implementere DBUpgradinator, Java. Proof-of-concept - implementasjonen av KVolve er skrevet i C. I et objektorientert språk som Java kan klasser brukes til å modellere oppdateringsspesifikasjonen. En klasse kalt `AbstractAggregateTransformer` realiserer både oppdateringsspesifikasjonen, ved å holde på to tilstandsvariable som indikerer navnet på en skjemaversjon som kommer før en annen, og dets transformasjonsfunksjon.

KVolve - implementasjonen til \cite{saur2016} kan også brukes til å oppgradere applikasjonstjenere, i artikkelen brukes Redis - modulen \underline{Amico} som et praktisk eksempel. I tillegg er KVolve innstilt på å vise et logisk konsistent bilde på datalget for webapplikasjonen som opererer på den, av hensyn til \cite{dumitras2009nodowntime} sine krav referert til i delkapittel \ref{imagolist}. Når man implementerer en liknende tjeneste i en høytilgjengelig applikasjon må man være obs på at designvalgene gjort i Amazon Dynamo er gjort primært for å fremme tilgjengelighet for skriveoperasjoner.